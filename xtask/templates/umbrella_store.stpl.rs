//! Thread-safe grammar store for caching compiled grammars.
//!
//! The `GrammarStore` holds compiled grammars that can be shared across threads.
//! Each grammar is compiled once and cached for reuse.
//!
//! # Generated Code
//!
//! This file is automatically generated from the grammar registry
//! (`langs/group-*/*/def/arborium.kdl`). Do not edit manually.

use std::collections::HashMap;
use std::sync::{Arc, RwLock};

#[allow(unused_imports)]
use arborium_highlight::tree_sitter::{CompiledGrammar, GrammarConfig};

/// Thread-safe cache of compiled grammars.
///
/// Grammars are compiled on first access and cached. The store can be shared
/// across threads via `Arc<GrammarStore>`.
///
/// # Example
///
/// ```rust,ignore
/// use std::sync::Arc;
///
/// // Create store (automatically populated with available grammars)
/// let store = Arc::new(GrammarStore::new());
///
/// // Share across threads
/// let store2 = store.clone();
/// std::thread::spawn(move || {
///     let grammar = store2.get("rust").unwrap();
///     // Use grammar...
/// });
/// ```
pub struct GrammarStore {
    grammars: RwLock<HashMap<String, Arc<CompiledGrammar>>>,
}

impl Default for GrammarStore {
    fn default() -> Self {
        Self::new()
    }
}

impl GrammarStore {
    /// Create a new empty grammar store.
    pub fn new() -> Self {
        Self {
            grammars: RwLock::new(HashMap::new()),
        }
    }

    /// Get a grammar by language name, compiling and caching it if needed.
    ///
    /// Returns `None` if the language is not supported.
    pub fn get(&self, language: &str) -> Option<Arc<CompiledGrammar>> {
        let normalized = Self::normalize_language(language);

        // Fast path: check if already cached
        {
            let grammars = self.grammars.read().unwrap();
            if let Some(grammar) = grammars.get(normalized) {
                return Some(grammar.clone());
            }
        }

        // Slow path: compile and cache
        let grammar = Self::compile_grammar(normalized)?;
        let grammar = Arc::new(grammar);

        {
            let mut grammars = self.grammars.write().unwrap();
            // Double-check in case another thread compiled it
            if let Some(existing) = grammars.get(normalized) {
                return Some(existing.clone());
            }
            grammars.insert(normalized.to_string(), grammar.clone());
        }

        Some(grammar)
    }

    /// Normalize a language name to its canonical form.
    fn normalize_language(language: &str) -> &'static str {
        match language {
            // Aliases (generated from arborium.kdl)
<% for (alias, canonical) in aliases { %>
            "<%= alias %>" => "<%= canonical %>",
<% } %>
            // Known canonical IDs pass through as-is
            // (leak the string to get &'static str - this is fine since language names are finite)
            _ => Box::leak(language.to_string().into_boxed_str()),
        }
    }

    /// Compile a grammar for a language.
    #[allow(unused_variables)]
    fn compile_grammar(language: &str) -> Option<CompiledGrammar> {
        macro_rules! try_lang {
            ($feature:literal, $module:ident, $primary:literal) => {
                #[cfg(feature = $feature)]
                if language == $primary {
                    let config = GrammarConfig {
                        language: crate::$module::language().into(),
                        highlights_query: &crate::$module::HIGHLIGHTS_QUERY,
                        injections_query: crate::$module::INJECTIONS_QUERY,
                        locals_query: crate::$module::LOCALS_QUERY,
                    };
                    return CompiledGrammar::new(config).ok();
                }
            };
        }

        // All languages (generated from arborium.kdl)
<% for (feature, module, grammar_id) in languages { %>
        try_lang!("<%= feature %>", <%= module %>, "<%= grammar_id %>");
<% } %>

        None
    }
}
